### Roadmap

**任务书核心内容提炼：**

这个课程设计的核心是**在裸机(Bochs模拟器)上，不依赖任何现成的OS，实现一个支持多任务切换的保护模式雏形**。你需要从最底层做起，手动进行保护模式初始化、地址映射、任务定义与切换、以及简单的任务调度。

**任务等级与目标：**

课程设计分为四个级别，难度和分数上限依次递增：

*   **级别 1 (≤70 分):** 实现保护模式初始化，并进行不同权限级别的代码跳转。
*   **级别 2 (≤80 分):** 定义两个任务 (A 和 B)，实现从任务 A 到任务 B 的单向切换，且任务 A 和 B 的功能代码（输出字符串）都运行在用户态。
*   **级别 3 (≤95 分):** 实现任务 A 和 B 的循环切换，且两者均为死循环，通过时钟中断服务程序进行切换。
*   **级别 4 (≤100 分):** 定义多个任务，每个任务具有不同的优先级，在时钟中断服务程序中采用“优先数调度算法”实现多任务切换，且任务的显示时长与优先级成正比。

**最终目标（级别4）:**

在 Bochs 模拟器中，创建多个不同优先级的任务，每个任务循环在屏幕相同位置输出不同的字符串（例如：VERY, LOVE, HUST, MRSU）。所有任务在可配置的时钟周期（例如 50ms）驱动下进行调度，调度策略采用“优先数进程调度策略”。每个字符串的持续显示时间长度应体现优先级的差异，即优先级越高，显示时间越长。

**开发环境与工具：**

*   **操作系统:** Ubuntu 16.04 或 Ubuntu 20.10
*   **汇编器:** NASM
*   **虚拟机:** Bochs (包含 bximage 工具)
*   **软盘映像:** freedos.img (系统盘) 和自制的用户软盘映像 (存放测试程序)
*   **参考资料:** 于渊的《一个操作系统的实现》前三章，以及课程提供的相关课件和代码示例。

**Roadmap (按照顺序需要做的事情):**

**一、 环境搭建与准备 (重要且基础，建议分配足够的时间)**

1. **安装 Ubuntu 系统:**  选择 Ubuntu 16.04 或 20.10 版本，并进行安装。

2. **安装 NASM:** 使用 `sudo apt-get install nasm` 命令安装 NASM 汇编器，并通过编译一个简单的汇编程序来验证安装是否成功。

3. **安装 Bochs:** 使用 `sudo apt-get install bochs vgabios bochs-x bximage` 命令安装 Bochs 虚拟机及其相关工具。使用 `whereis bochs` 确认安装路径，后面配置 `bochsrc.txt` 文件会用到。

   ```
   /usr/bin/bochs /usr/lib/bochs /usr/share/bochs /usr/share/man/man1/bochs.1.gz
   ```

4. **下载 freedos.img:** 从 Bochs 官网下载 `freedos.img` 软盘映像文件，解压后保留 `a.img` 并重命名为 `freedos.img` 作为系统启动盘。

   ```
   wget https://bochs.sourceforge.io/guestos/freedos-img.tar.gz
   tar -zxvf freedos-img.tar.gz
   ```

5. **创建用户软盘映像:** 使用 `bximage` 工具创建一个空白的 1.44M 软盘映像文件 (例如 `pmtest.img`)，用于存放你的测试程序。

6. **配置 bochsrc.txt:**  根据你的 Bochs 安装路径，正确配置 `bochsrc.txt` 文件，主要包括内存大小、BIOS 和 VGA ROM 映像文件路径、软盘映像文件路径和启动设备等。

7. **测试 Bochs:** 使用 `bochs -f bochsrc.txt` 命令启动 Bochs，看是否能够正常加载 `freedos.img`。如果能进入 Freedos，尝试使用 `format.exe B:` 格式化你创建的用户软盘映像 (pmtest.img)，然后使用 `mount` 命令将其挂载到 Ubuntu 的某个目录下，方便后续拷贝测试程序。

   ```
   mount -o loop ./pmtest.img /mnt/floppyB
   sudo cp -r ./pmtestSrc /mnt/floppyB
   ```

**二、 学习与理解基础知识 (这是理论基础，确保充分理解)**

1. **保护模式:** 深入学习 x86 的保护模式机制，特别是以下几个方面：
    *   段机制：理解段描述符、段选择子、全局描述符表 (GDT)、局部描述符表 (LDT) 的概念和作用。
    *   权限级别：理解 DPL、RPL、CPL 的含义以及权限检查的规则。
    *   地址映射：理解逻辑地址、线性地址、物理地址之间的转换关系，以及段式映射和页式映射的原理。
    *   任务状态段 (TSS)：理解 TSS 的结构和作用，以及它在任务切换中的重要性。
2. **Bochs 调试:** 熟悉 Bochs 的基本调试命令，例如：
    *   `c` (continue): 继续执行
    *   `s` (step): 单步执行
    *   `b` (break): 设置断点
    *   `x` (examine): 查看内存
    *   `r` (registers): 查看寄存器
    *   `info registers`:查看所有寄存器内容
    *   `ctrl+c`:中断运行

3. **中断机制：**理解中断的产生、中断处理流程，特别是时钟中断，还有就是8259A可编程中断控制器的工作原理。
4. **汇编语言:** 掌握 NASM 汇编语言的基本语法，特别是与保护模式相关的指令，例如：`lgdt`, `lidt`, `mov cr0`, `jmp far`, `iret` 等。

**三、 代码实践 (逐步实现各个级别的任务)**

**级别 1：保护模式初始化与权限跳转**

1. **创建 GDT:** 参考 `pmtest1.asm` 或幻灯片 35-36 页的代码，定义 GDT，包括空描述符、内核代码段描述符、内核数据段描述符和显示内存段描述符。
2. **加载 GDTR:** 使用 `lgdt` 指令将 GDT 的基地址和界限加载到 GDTR 寄存器中。
3. **设置 CR0:** 通过修改 CR0 寄存器的 PE 位，启用保护模式。
4. **代码跳转:** 使用 `jmp far` 指令跳转到保护模式下的代码段执行，并加载正确的段选择子到各个段寄存器。
5. **权限跳转:** 设计实验，尝试从低权限级别的代码段跳转到高权限级别的代码段，以及从高权限级别的代码段跳转到低权限级别的代码段，观察 Bochs 的运行结果，理解权限检查的作用。

**级别 2：单任务实现与切换**

1. **定义任务 A 和 B 的 TSS 和 LDT:**
    *   为每个任务创建一个 TSS 结构，设置好任务的栈指针、LDT 选择子等字段。
    *   为每个任务创建一个 LDT 结构，包含任务的代码段描述符和数据段描述符。
2. **完善 GDT:** 在 GDT 中添加任务 A 和 B 的 TSS 描述符和 LDT 描述符。
3. **任务 A 的实现:** 编写任务 A 的代码，实现循环输出字符串的功能，例如输出 "A"。
4. **任务 B 的实现:** 编写任务 B 的代码，实现循环输出字符串的功能，例如输出 "B"。
5. **任务切换:** 在任务 A 的代码中，使用 `jmp far` 指令，通过任务 A 的 TSS 描述符中的 LDT 选择子，跳转到任务 B 的 TSS，从而切换到任务 B 执行，注意这里需要设置好所有寄存器的内容。

**级别 3：双任务循环切换**

1. **创建 IDT:** 定义 IDT，并设置好时钟中断处理程序的入口地址。
2. **加载 IDTR:** 使用 `lidt` 指令将 IDT 的基地址和界限加载到 IDTR 寄存器中。
3. **编写时钟中断处理程序:** 参考幻灯片 74 页，编写时钟中断服务程序，在程序中实现任务 A 和 B 之间的切换：
    *   保存当前任务的上下文到其 TSS 中。
    *   使用 `ltr` 指令加载另一个任务的 TSS 选择子。
    *   使用 `iret` 指令返回到另一个任务的代码段继续执行。
4. **初始化 8259A:** 对 8259A 可编程中断控制器进行初始化，并打开时钟中断。
5. **启用时钟中断:** 设置定时器/计数器，使其产生周期性的时钟中断。

**级别 4：多任务优先数调度**

1. **定义多个任务:**  定义更多的任务（例如四个），每个任务循环输出不同的字符串，并为每个任务设置一个优先数。
2. **修改时钟中断处理程序:** 实现优先数调度算法：
    *   在每个时钟中断到来时，根据任务的优先数选择下一个要执行的任务。
    *   优先数大的任务获得更多的执行机会，从而实现更长的显示时间。
    *   可以使用一个简单的数组或链表来维护任务队列。
3. **调整任务结构：**将每个任务都设置为死循环，让他们一直尝试获取cpu进行输出。

**四、 调试与测试**

1. **使用 Bochs 调试:** 在 Bochs 中运行你的程序，使用 Bochs 的调试命令跟踪程序的执行，检查各个寄存器的值、内存的值以及程序的跳转是否正确。
2. **观察运行结果:** 观察 Bochs 的输出窗口，验证任务切换是否正常，字符串的显示时间是否与优先级相符。
3. **修改与完善:** 根据测试结果，修改和完善你的代码，直到满足所有要求为止。

**五、 报告撰写**

1. **按照模板要求:** 根据课程设计报告的模板要求，撰写实验报告。
2. **内容完整:** 报告内容应包括实验目的、实验环境、实验原理、实验步骤、实验结果、实验总结等。
3. **代码清晰:** 在报告中附上你的代码，并添加必要的注释，解释代码的功能和实现思路。
4. **图文并茂:** 使用 Bochs 的截图或录屏来展示你的实验结果，使报告更加直观易懂。

**一些建议：**

*   **先易后难：** 建议你从级别 1 开始，逐步实现各个级别的任务，不要一开始就想着实现级别 4 的所有功能。
*   **多思考，多实践：** 在编写代码之前，一定要充分理解相关的原理，并在实践中不断思考和总结。
*   **参考示例代码：** 课程提供的示例代码和于渊的《一个操作系统的实现》一书中的代码都是很好的参考资料，可以帮助你理解保护模式的实现细节。
*   **善用 Bochs 调试工具：** Bochs 的调试工具可以帮助你快速定位和解决问题，一定要熟练掌握。
*   **保持良好的代码风格：** 代码要简洁易懂，添加必要的注释，方便自己和他人阅读。

---

### 课程评分

![image-20250127141942205](C:\Users\kobedai\AppData\Roaming\Typora\typora-user-images\image-20250127141942205.png)

![image-20250202152551842](C:\Users\kobedai\AppData\Roaming\Typora\typora-user-images\image-20250202152551842.png)

![image-20250127142029439](C:\Users\kobedai\AppData\Roaming\Typora\typora-user-images\image-20250127142029439.png)

---

### 视频录制

这是本次操作系统课设的讲解视频。我将展示我完成的**第四级别**的操作系统课设，讲解代码的实现过程并演示程序运行结果。程序的整体实现主要参考了教材代码的`pmtest8`和`pmtest9`两个，也就是多页表和时钟中断的两个代码。

`lib`代码和`pmtest9`提供的是完全一致的，没有改动；`pm`代码文件额外增加了定义`task`部分的宏，以减少主体代码的冗余。

然后是主体程序`Mutitasking`；代码的开头定义了一些常量，包括四个任务的页目录和页表的起始地址。这些地址在后面的内存管理中会用到。

接下来程序的起始地址被设置为 0100h，这是一个传统的实模式程序起始地址。然后，我们通过 `jmp LABEL_BEGIN` 跳转到程序的入口点。

**GDT（全局描述符表）**

接下来，我们看到的是 GDT 的定义。GDT 是保护模式下重要的一个数据结构，定义代码段、数据段、堆栈段等各种段的属性和基地址。
*   首先是空的描述符 `LABEL_GDT`，这是必须的。
*   `LABEL_DESC_NORMAL` 是一个普通的段描述符。
*   `LABEL_DESC_FLAT_C` 和 `LABEL_DESC_FLAT_RW` 分别是用于 32 位代码段和数据段的平坦模式描述符，它们的基地址都是 0，大小都是 4GB。
*   `LABEL_DESC_CODE32` 是一个 32 位的代码段描述符。
*   `LABEL_DESC_CODE16` 是一个 16 位的代码段描述符，在从保护模式返回实模式时会用到。
*   `LABEL_DESC_DATA` 是数据段描述符。
*   `LABEL_DESC_STACK` 是堆栈段描述符。
*   `LABEL_DESC_VIDEO` 是显存段描述符，用于直接操作显存。
*   `LABEL_DESC_TSS0`, `LABEL_DESC_TSS1`, `LABEL_DESC_TSS2`, `LABEL_DESC_TSS3` 是四个任务的 TSS 描述符。TSS (Task State Segment) 用于保存任务的上下文信息。
*   `LABEL_TASK0_DESC_LDT`, `LABEL_TASK1_DESC_LDT`, `LABEL_TASK2_DESC_LDT`, `LABEL_TASK3_DESC_LDT` 是四个任务的 LDT 描述符。LDT (Local Descriptor Table) 可以为每个任务定义自己独立的段描述符表。

`GdtLen` 计算了 GDT 的长度，`GdtPtr` 定义了 GDTR 需要加载的内容，包括 GDT 的界限和基地址。

接下来是 GDT 选择子的定义，这些选择子用于在程序中引用 GDT 中的各个段描述符。比如 `SelectorNormal`，`SelectorFlatC`， `SelectorCode32` 等。

**LDT 和任务段定义**

接下来，我们看到的是四个任务的定义，这里使用了 `DefineTask` 宏。这个宏会为每个任务定义一个 LDT，并在 LDT 中定义任务的代码段、数据段和堆栈段。每个任务的代码段都有一个字符串输出。

**IDT（中断描述符表）**

接下来是 IDT 的定义。IDT 用于定义中断处理程序的入口地址。
*   这里首先初始化了前32个中断向量指向 `SpuriousHandler` 虚假中断处理程序，
*   然后第 32 号中断向量指向时钟中断处理程序 `ClockHandler`，
*   接着初始化了 95 个中断向量指向 `SpuriousHandler`，
*   最后 128号中断向量指向用户自定义中断处理程序 `UserIntHandler`。
* `IdtLen` 计算了 IDT 的长度，`IdtPtr` 定义了 IDTR 需要加载的内容，包括 IDT 的界限和基地址。

**数据段**

接下来是数据段的定义，这里定义了很多全局变量，包括实模式下的消息字符串、内存检测结果、屏幕显示位置、内存大小等等。也包括了保护模式下的全局变量，用于屏幕显示和任务切换。比较重要的是 `_TaskPriority`，用于存放任务的优先级，以及 `_LeftTicks`，用于记录任务剩余的运行时间。

**全局堆栈段**

接下来是全局堆栈段的定义，这是保护模式下全局使用的堆栈。

**16 位代码段**

下面我们进入到 16 位代码段。这是程序最开始执行的代码，主要完成以下任务：
*   设置段寄存器，初始化堆栈。
*   获取内存大小。
*   初始化 GDT 和 IDT 的基地址。
*   保存 IDTR 的值。
*   关闭中断。
*   打开 A20 地址线。
*   设置 CR0 寄存器，进入保护模式。
*   跳转到 32 位代码段。

在 `LABEL_REAL_ENTRY` 处，是从保护模式返回实模式后的入口点，主要完成以下任务：
*   恢复段寄存器和堆栈。
*   恢复 IDTR 的值。
*   恢复中断屏蔽寄存器的值。
*   关闭 A20 地址线。
*   开中断。
*   返回 DOS。

**32 位代码段**

接下来是 32 位代码段，这是进入保护模式后程序执行的代码。
*   首先设置各个段寄存器。
*   初始化 8253 和 8259 芯片。
*   清屏，并显示一些字符串。
*   计算页表的数量。
*   初始化四个任务的页表。
*   初始化每个任务的ticks。
*   打开中断。
*   加载 CR3 和 TSS。
*   打开分页机制。
*   跳转到提示信息输出，然后进行任务切换。
*   `ClockHandler` 是时钟中断处理程序，每次时钟中断发生时都会执行。它负责维护每个任务的剩余时间，并且进行任务切换。
*   `UserIntHandler` 和 `SpuriousHandler` 是其他中断处理程序。
*   `InitPageTable` 是初始化页表的宏。

**`lib.inc`**

最后，我们看到 `lib.inc` 文件包含了用于显示字符串，初始化 8253 和 8259 芯片的库函数。

**16 位代码段**

最后，我们回到 16 位代码段，这里主要是从保护模式返回实模式的代码。它会将 CR0 寄存器的值修改，关闭分页机制，并跳转回实模式。

**视频结束**

以上就是我本次操作系统的课设的全部代码讲解。这段代码实现了多任务的优先级调度，并且演示了如何在保护模式下进行内存管理和任务切换。代码的复杂性较高，需要仔细理解每一个细节。希望这个视频能够帮助大家更好地理解操作系统的原理。谢谢大家！
